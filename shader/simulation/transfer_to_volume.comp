// Builds velocity grid from particles and llgrid
// Uses shepard interpolation on particles.

#version 450

#include "../utilities.glsl"
#include "bindings_transfer_velocity.glsl"

COMPUTE_PASS_VOLUME

void gatherStaggeredVelocitiesFromLinkedList(inout float velocityComponent, inout float totalWeight, vec3 staggeredVelocitySamplePosition,
                                             ivec3 llgridCoord) {
    uint particleIndex = imageLoad(LinkedListDualGrid, llgridCoord).r - 1;

    // A cell starts out with 8 particles, ideally that stays roughly constant.
    for (int i = 0; i < 12 && particleIndex != INVALID_LINKED_LIST_PTR; ++i) {
        vec3 toSamplePosition = staggeredVelocitySamplePosition - Particles[particleIndex].Position;
        vec3 offset = saturate(vec3(1.0) - abs(toSamplePosition));
        float weight = offset.x * offset.y * offset.z;

        velocityComponent += weight * dot(Particles[particleIndex].VelocityMatrix[VelocityTransferComponent], vec4(toSamplePosition, 1.0));
        totalWeight += weight;

        particleIndex = Particles[particleIndex].LinkedListNext;
    }
}

void main() {
    ivec3 gridCoord = ivec3(gl_GlobalInvocationID);
    uint marker = imageLoad(MarkerVolume, gridCoord).r;

    // in order to define boundary *wall* velocities for the bottom/left/back boundary, we need to mark those cells as solid.
    // (top/right/front are marked implicitely and there are walls readily available!)
    if (VelocityTransferComponent == 0 && any(lessThanEqual(gridCoord, ivec3(0)))) {
        marker = CELL_SOLID;
        imageStore(MarkerVolume, gridCoord, uvec4(CELL_SOLID));
    }

    // No need to clear velocity volume since anyone sampling it outside needs special handling anyway
    if (marker != CELL_FLUID)
        return;

    vec3 staggeredVelocitySamplePosition = vec3(gl_GlobalInvocationID) + vec3(0.5);
    staggeredVelocitySamplePosition[VelocityTransferComponent] += 0.5;
    float velocityComponent = 0.0;
    float velocityWeight = 0.0;
    gatherStaggeredVelocitiesFromLinkedList(velocityComponent, velocityWeight, staggeredVelocitySamplePosition, gridCoord - ivec3(0, 0, 0));
    gatherStaggeredVelocitiesFromLinkedList(velocityComponent, velocityWeight, staggeredVelocitySamplePosition, gridCoord - ivec3(1, 0, 0));
    gatherStaggeredVelocitiesFromLinkedList(velocityComponent, velocityWeight, staggeredVelocitySamplePosition, gridCoord - ivec3(0, 1, 0));
    gatherStaggeredVelocitiesFromLinkedList(velocityComponent, velocityWeight, staggeredVelocitySamplePosition, gridCoord - ivec3(1, 1, 0));
    gatherStaggeredVelocitiesFromLinkedList(velocityComponent, velocityWeight, staggeredVelocitySamplePosition, gridCoord - ivec3(0, 0, 1));
    gatherStaggeredVelocitiesFromLinkedList(velocityComponent, velocityWeight, staggeredVelocitySamplePosition, gridCoord - ivec3(1, 0, 1));
    gatherStaggeredVelocitiesFromLinkedList(velocityComponent, velocityWeight, staggeredVelocitySamplePosition, gridCoord - ivec3(0, 1, 1));
    gatherStaggeredVelocitiesFromLinkedList(velocityComponent, velocityWeight, staggeredVelocitySamplePosition, gridCoord - ivec3(1, 1, 1));

    if (velocityWeight > 0.0)
        velocityComponent /= velocityWeight;
    velocityComponent += GravityGridSpace[VelocityTransferComponent] * Time.SimulationDelta;

    imageStore(VelocityComponentVolume, gridCoord, velocityComponent.xxxx);
}