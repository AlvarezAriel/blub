// Computes velocity divergence of VelocityVolume

#version 450

#include "hybrid_fluid.glsl"
#include "per_frame_resources.glsl"
#include "utilities.glsl"

layout(set = 2, binding = 0) uniform texture3D VelocityVolume;
// layout(set = 2, binding = 1) uniform texture3D DivergenceVolume;
// layout(set = 2, binding = 2) uniform texture3D PressureVolumeRead;
layout(set = 2, binding = 3, r32f) uniform restrict image3D DivergenceVolume;

COMPUTE_PASS_VOLUME

void main() {
    ivec3 gridCoord = ivec3(gl_GlobalInvocationID);
    vec3 velocity = texelFetch(VelocityVolume, gridCoord, 0).xyz;
    uvec3 maxGridCoord = gl_NumWorkGroups * gl_WorkGroupSize - uvec3(1);

    // Don't compute divergence if there's no fluid
    vec4 mid = texelFetch(VelocityVolume, gridCoord, 0);
    float isFluid = mid.w;
    if (isFluid == 0.0)
        return;

    vec4 x0 = texelFetch(VelocityVolume, gridCoord - ivec3(1, 0, 0), 0);
    vec4 x1 = texelFetch(VelocityVolume, gridCoord + ivec3(1, 0, 0), 0);
    vec4 y0 = texelFetch(VelocityVolume, gridCoord - ivec3(0, 1, 0), 0);
    vec4 y1 = texelFetch(VelocityVolume, gridCoord + ivec3(0, 1, 0), 0);
    vec4 z0 = texelFetch(VelocityVolume, gridCoord - ivec3(0, 0, 1), 0);
    vec4 z1 = texelFetch(VelocityVolume, gridCoord + ivec3(0, 0, 1), 0);
    float divergence = ((x1.x - x0.x) + (y1.y - y0.y) + (z1.z - z0.z)) * 0.5;

    imageStore(DivergenceVolume, gridCoord, vec4(divergence));
}
