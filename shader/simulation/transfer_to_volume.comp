// Builds velocity grid from particles and llgrid
// Uses shepard interpolation on particles.

#version 450

#include "../utilities.glsl"
#include "bindings_write_particles_volume.glsl"

COMPUTE_PASS_VOLUME

void gatherStaggeredVelocitiesFromLinkedList(inout vec3 velocity, inout vec3 totalWeights, vec3 cellCenter, ivec3 llgridCoord) {
    uint particleIndex = imageLoad(LinkedListDualGrid, llgridCoord).r - 1;

    // while (particleIndex != INVALID_LINKED_LIST_PTR) {
    for (int i = 0; i < 32 && particleIndex != INVALID_LINKED_LIST_PTR; ++i) {
        vec3 toGridCenter = cellCenter - Particles[particleIndex].Position;
        vec3 dCenter = saturate(vec3(1.0) - abs(toGridCenter));
        vec3 dOffset = saturate(vec3(1.0) - abs(toGridCenter + vec3(0.5)));

        vec3 weights = vec3(dOffset.x * dCenter.y * dCenter.z, dCenter.x * dOffset.y * dCenter.z, dCenter.x * dCenter.y * dOffset.z);
        velocity.xyz += weights * vec3(dot(Particles[particleIndex].VelocityMatrix[0], vec4(toGridCenter + vec3(0.5, 0.0, 0.0), 1.0)),
                                       dot(Particles[particleIndex].VelocityMatrix[1], vec4(toGridCenter + vec3(0.0, 0.5, 0.0), 1.0)),
                                       dot(Particles[particleIndex].VelocityMatrix[2], vec4(toGridCenter + vec3(0.0, 0.0, 0.5), 1.0)));
        totalWeights += weights;
        particleIndex = Particles[particleIndex].LinkedListNext;
    }
}

void main() {
    vec3 cellCenter = vec3(gl_GlobalInvocationID) + vec3(0.5); // center of the cell
    ivec3 gridCoord = ivec3(gl_GlobalInvocationID);
    vec3 velocity = vec3(0.0);
    vec3 weights = vec3(0.0);

    [[unroll]] for (int z = -1; z <= 1; ++z) {
        [[unroll]] for (int y = -1; y <= 1; ++y) {
            [[unroll]] for (int x = -1; x <= 1; ++x) {
                gatherStaggeredVelocitiesFromLinkedList(velocity, weights, cellCenter, gridCoord + ivec3(x, y, z));
            }
        }
    }

    [[flatten]] if (weights.x > 0.0) { velocity.x /= weights.x; }
    [[flatten]] if (weights.y > 0.0) { velocity.y /= weights.y; }
    [[flatten]] if (weights.z > 0.0) { velocity.z /= weights.z; }

    // Apply global forces. In the spirit of extrapolation this applies to air cells as well!
    velocity.xyz += vec3(0.0, -9.81, 0.0) * Time.SimulationDelta;

    // Mark this cell only as a fluid cell if there is actually fluid inside.
    // Note that air cells still get velocity with our transfer scheme, which is great because otherwise we would need to extrapolate to it!
    uint marker = imageLoad(LinkedListDualGrid, gridCoord).r == 0 ? CELL_AIR : CELL_FLUID;

    // Reinforce global boundaries.
    // in order to define boundary *wall* velocities for the bottom/left/back boundary, we need to mark those cells as solid.
    // (top/right/front are marked implicitely and there are walls readily available!)
    [[flatten]] if (any(lessThanEqual(gridCoord, ivec3(0)))) { marker = CELL_SOLID; }
    // TODO: This probably needs to be a separate pass as we can't really do this on the fly in compute divergence
    // (which looks at wall differences within a cell rather than what's in the next cell)
    ivec3 gridSize = ivec3(textureSize(PressureVolume, 0));
    velocity = enforceGlobalWallBoundaryCondition(velocity, gridCoord, gridSize);

    imageStore(VelocityVolume, gridCoord, vec4(velocity, 0.0));
    imageStore(MarkerVolume, gridCoord, marker.xxxx);
}