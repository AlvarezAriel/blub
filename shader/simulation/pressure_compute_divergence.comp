// Computes velocity divergence of VelocityVolumes
// This is the b in the Ax=b equation we're solving.
// Since x (the pressure p!) starts out with zero it also doubles as initial residual of the (preconditioned) conjugate gradient solver!

#version 460

#include "pressure.glsl"

// layout(set = 3, binding = 0) buffer restrict PcgScalars_ { PcgScalars Scalars; };
// layout(set = 3, binding = 1) uniform texture3D Read0;
// layout(set = 3, binding = 2) uniform texture3D Read1;
layout(set = 3, binding = 3, r32f) uniform restrict image3D DivergenceVolume;

COMPUTE_PASS_VOLUME

float computeDivergenceForDirection(ivec3 coord, texture3D velocityVolume, const uint component) {
    ivec3 neighborCoord = coord;
    neighborCoord[component] -= 1;

    uint oppositeWallType = texelFetch(MarkerVolume, neighborCoord, 0).x;
    if (oppositeWallType == CELL_FLUID)
        return texelFetch(velocityVolume, coord, 0).x - texelFetch(velocityVolume, neighborCoord, 0).x;
    else if (oppositeWallType == CELL_SOLID)
        return texelFetch(velocityVolume, coord, 0).x;
    else
        return 0.0;
}

void main() {
    ivec3 gridCoord = ivec3(gl_GlobalInvocationID);

    // Don't compute divergence if there's no fluid
    // Divergence tells us how much fluid is going in/out. If we're at a air/solid cell then that's clearly zero as there's no fluid in the first
    // place!
    float divergence = 0.0;
    if (texelFetch(MarkerVolume, gridCoord, 0).x == CELL_FLUID) {
        divergence += computeDivergenceForDirection(gridCoord, VelocityVolumeX, 0);
        divergence += computeDivergenceForDirection(gridCoord, VelocityVolumeY, 1);
        divergence += computeDivergenceForDirection(gridCoord, VelocityVolumeZ, 2);
    }

    imageStore(DivergenceVolume, gridCoord, divergence.xxxx);
}
