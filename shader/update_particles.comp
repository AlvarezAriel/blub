#version 450

#include "hybrid_fluid.glsl"
#include "particles.glsl"
#include "per_frame_resources.glsl"
#include "utilities.glsl"

layout(set = 2, binding = 0) buffer restrict ParticleBuffer { Particle Particles[]; };
layout(set = 2, binding = 1) uniform texture3D VelocityVolume;

COMPUTE_PASS_PARTICLES

vec3 InterpolateTrilinear(vec3 v_000, vec3 v_100, vec3 v_010, vec3 v_110, vec3 v_001, vec3 v_101, vec3 v_011, vec3 v_111, vec3 interpolants) {
    return mix(mix(mix(v_000, v_100, interpolants.x), mix(v_010, v_110, interpolants.x), interpolants.y),
               mix(mix(v_001, v_101, interpolants.x), mix(v_011, v_111, interpolants.x), interpolants.y), interpolants.z);
}

void main() {
    uint particleIndex = gl_GlobalInvocationID.x;
    if (particleIndex >= NumParticles)
        return;

    vec3 gridSize = textureSize(VelocityVolume, 0);
    vec3 gridTexelSizeNormalized = 1.0 / gridSize;

    // Sample all 8 neighboring velocity grid cells
    //
    // Notes from experimentation texture sampling:
    // * texelFetch is either slower or as fast. Previously allowed particles outside the volume in which case it was better since we got boundaries
    // for free wiht SamplerPointClamp
    // * using linear sampler repeatedly (6x linear sample instead of 8x direct sample + manual interpolate) is indeed slower
    // (as one would hope for sanity's sake :))
    vec3 originalPosition = Particles[particleIndex].Position;
    vec3 offsetPosition = originalPosition - vec3(0.5);
    ivec3 volumeCoordMin = ivec3(offsetPosition);
    ivec3 volumeCoordMax = volumeCoordMin + ivec3(1, 1, 1);
    vec3 v_000 = texelFetch(VelocityVolume, volumeCoordMin, 0).xyz;
    vec3 v_100 = texelFetch(VelocityVolume, ivec3(volumeCoordMax.x, volumeCoordMin.yz), 0).xyz;
    vec3 v_010 = texelFetch(VelocityVolume, ivec3(volumeCoordMin.x, volumeCoordMax.y, volumeCoordMin.z), 0).xyz;
    vec3 v_110 = texelFetch(VelocityVolume, ivec3(volumeCoordMax.xy, volumeCoordMin.z), 0).xyz;
    vec3 v_001 = texelFetch(VelocityVolume, ivec3(volumeCoordMin.xy, volumeCoordMax.z), 0).xyz;
    vec3 v_101 = texelFetch(VelocityVolume, ivec3(volumeCoordMax.x, volumeCoordMin.y, volumeCoordMax.z), 0).xyz;
    vec3 v_011 = texelFetch(VelocityVolume, ivec3(volumeCoordMin.x, volumeCoordMax.yz), 0).xyz;
    vec3 v_111 = texelFetch(VelocityVolume, volumeCoordMax, 0).xyz;

    // Update velocity and the APIC affine matrix.
    // Trilinear interpolation for velocity.
    vec3 interpolants = fract(offsetPosition);
    vec3 v_x00 = mix(v_000, v_100, interpolants.x);
    vec3 v_x01 = mix(v_001, v_101, interpolants.x);
    vec3 v_x10 = mix(v_010, v_110, interpolants.x);
    vec3 v_x11 = mix(v_011, v_111, interpolants.x);
    vec3 v_xy0 = mix(v_x00, v_x10, interpolants.y);
    vec3 v_xy1 = mix(v_x01, v_x11, interpolants.y);
    vec3 newVelocity = mix(v_xy0, v_xy1, interpolants.z);
    // The Apic Matrix is the jacobi matrix of the velocity for fluids.
    vec3 cx = mix(mix(v_100, v_110, interpolants.y), mix(v_101, v_111, interpolants.y), interpolants.z) -
              mix(mix(v_000, v_010, interpolants.y), mix(v_001, v_011, interpolants.y), interpolants.z);
    vec3 cy = mix(v_x10, v_x11, interpolants.z) - mix(v_x00, v_x01, interpolants.z);
    vec3 cz = v_xy1 - v_xy0;

    // Advect with Runge Kutta 4
    // confined to current cell for which we know velocities are defined and we already sampled all corners - which makes this relatively cheap.
    vec3 k1 = newVelocity;
    vec3 k2 = InterpolateTrilinear(v_000, v_100, v_010, v_110, v_001, v_101, v_011, v_111, saturate(interpolants + Time.SimulationDelta * 0.5 * k1));
    vec3 k3 = InterpolateTrilinear(v_000, v_100, v_010, v_110, v_001, v_101, v_011, v_111, saturate(interpolants + Time.SimulationDelta * 0.5 * k2));
    vec3 k4 = InterpolateTrilinear(v_000, v_100, v_010, v_110, v_001, v_101, v_011, v_111, saturate(interpolants + Time.SimulationDelta * k3));
    vec3 totalMovement = Time.SimulationDelta * (1.0 / 6.0) * (k1 + 2.0 * (k2 + k3) + k4);
    // vec3 totalMovement = newVelocity * Time.SimulationDelta; // Euler integration

    // Enforce boundary.
    // Moving particle back a bit resulted in a lot of sticky particles that are hard to get rid of.
    // vec3 clampedMovement = clamp(originalPosition + totalMovement, boundaryMin, boundaryMax) - originalPosition;
    // vec3 clampRatio = clampedMovement / totalMovement;
    // float clampFactor = min(min(clampRatio.x, clampRatio.y), clampRatio.z);
    vec3 newPosition = clamp(originalPosition + totalMovement, vec3(0.5), gridSize - vec3(0.5));

    Particles[particleIndex].Position = newPosition;
    Particles[particleIndex].VelocityMatrix[0] = vec4(cx, newVelocity.x);
    Particles[particleIndex].VelocityMatrix[1] = vec4(cy, newVelocity.y);
    Particles[particleIndex].VelocityMatrix[2] = vec4(cz, newVelocity.z);

    // PIC only
    // Particles[particleIndex].VelocityMatrix[0] = vec4(vec3(0), newVelocity.x);
    // Particles[particleIndex].VelocityMatrix[1] = vec4(vec3(0), newVelocity.y);
    // Particles[particleIndex].VelocityMatrix[2] = vec4(vec3(0), newVelocity.z);
}