// Subtracts pressure gradient from velocity volume to make it divergence free.
// (applies pressure forces)

#version 450

#include "../utilities.glsl"
#include "bindings_write_particles_volume.glsl"

COMPUTE_PASS_VOLUME

float computeCorrectedVelocityForDirection(ivec3 coord, float pressureAtCenter, vec3 currentCellStaggeredVelocities, const uint component) {
    coord[component] += 1;

    uint neighborType = imageLoad(MarkerVolume, coord).x;
    float neighborPressure = neighborType == CELL_FLUID ? texelFetch(PressureVolume, coord, 0).x : 0.0;

    [[flatten]] if (neighborType == CELL_SOLID) {
        // At boundary cells the pressure should be such that fluid_velocity * boundary_normal == boundary_velocity * boundary_normal
        // No support for non-static boundary yet
        // -> No flow between boundary and non-boundary allowed.
        // To avoid sticking to walls we allow velocity away from it even though it violates continuity equations.
        return min(0.0, currentCellStaggeredVelocities[component]);
    }
    else {
        return currentCellStaggeredVelocities[component] - (neighborPressure - pressureAtCenter);
    }
}

void main() {
    vec3 velocityGridPosition = vec3(gl_GlobalInvocationID);
    ivec3 gridCoord = ivec3(gl_GlobalInvocationID);

    uint cellType = imageLoad(MarkerVolume, gridCoord).x;
    if (cellType != CELL_FLUID)
        return;

    vec3 velocity = imageLoad(VelocityVolume, gridCoord).xyz;
    float pressureAtCenter = texelFetch(PressureVolume, gridCoord, 0).x;
    velocity.x = computeCorrectedVelocityForDirection(gridCoord, pressureAtCenter, velocity, 0);
    velocity.y = computeCorrectedVelocityForDirection(gridCoord, pressureAtCenter, velocity, 1);
    velocity.z = computeCorrectedVelocityForDirection(gridCoord, pressureAtCenter, velocity, 2);
    imageStore(VelocityVolume, gridCoord, velocity.xyzz);
}