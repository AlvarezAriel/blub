// Builds velocity grid from particles and llgrid
// Uses shepard interpolation on particles.

#version 450

#include "../utilities.glsl"
#include "bindings_write_particles_volume.glsl"

COMPUTE_PASS_VOLUME

void gatherStaggeredVelocitiesFromLinkedList(inout vec3 velocity, inout vec3 totalWeights, vec3 velocityGridPosition, ivec3 llgridCoord) {
    uint particleIndex = imageLoad(LinkedListDualGrid, llgridCoord).r - 1;

    // while (particleIndex != INVALID_LINKED_LIST_PTR) {
    for (int i = 0; i < 32 && particleIndex != INVALID_LINKED_LIST_PTR; ++i) {
        vec3 toGridCenter = velocityGridPosition - Particles[particleIndex].Position;
        vec3 dCenter = saturate(vec3(1.0) - abs(toGridCenter));
        vec3 dOffset = saturate(vec3(1.0) - abs(toGridCenter + vec3(0.5)));

        vec3 weights = vec3(dOffset.x * dCenter.y * dCenter.z, dCenter.x * dOffset.y * dCenter.z, dCenter.x * dCenter.y * dOffset.z);
        velocity.xyz += weights * vec3(dot(Particles[particleIndex].VelocityMatrix[0], vec4(toGridCenter + vec3(0.5, 0.0, 0.0), 1.0)),
                                       dot(Particles[particleIndex].VelocityMatrix[1], vec4(toGridCenter + vec3(0.0, 0.5, 0.0), 1.0)),
                                       dot(Particles[particleIndex].VelocityMatrix[2], vec4(toGridCenter + vec3(0.0, 0.0, 0.5), 1.0)));
        totalWeights += weights;
        particleIndex = Particles[particleIndex].LinkedListNext;
    }
}

void main() {
    vec3 velocityGridPosition = vec3(gl_GlobalInvocationID) + vec3(0.5); // velocity is stored at the center.
    ivec3 gridCoord = ivec3(gl_GlobalInvocationID);
    vec3 velocity = vec3(0.0);
    vec3 weights = vec3(0.0);

    [[unroll]] for (int z = -1; z <= 1; ++z) {
        [[unroll]] for (int y = -1; y <= 1; ++y) {
            [[unroll]] for (int x = -1; x <= 1; ++x) {
                gatherStaggeredVelocitiesFromLinkedList(velocity, weights, velocityGridPosition, gridCoord + ivec3(x, y, z));
            }
        }
    }

    // wouldn't this make sense? (doesn't work)
    // float marker = imageLoad(LinkedListDualGrid, gridCoord).r == 0 ? CELL_FLUID : CELL_AIR;
    float marker = CELL_AIR;

    [[flatten]] if (weights.x > 0.0) {
        velocity.x /= weights.x;
        marker = CELL_FLUID;
    }
    [[flatten]] if (weights.y > 0.0) {
        velocity.y /= weights.y;
        marker = CELL_FLUID;
    }
    [[flatten]] if (weights.z > 0.0) {
        velocity.z /= weights.z;
        marker = CELL_FLUID;
    }

    [[flatten]] if (marker == CELL_FLUID) {
        // Apply global forces.
        // todo: make configurable
        velocity.xyz += vec3(0.0, -9.81, 0.0) * Time.SimulationDelta;
    }

    // in order to define boundary wall velocities for the bottom/left/back boundary, we need to mark those cells as solid.
    [[flatten]] if (gridCoord.x == 0 || gridCoord.y == 0 || gridCoord.z == 0) marker = CELL_SOLID;

    imageStore(VelocityVolume, gridCoord, vec4(velocity, marker));
}