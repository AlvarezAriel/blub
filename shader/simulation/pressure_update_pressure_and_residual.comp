// Pressure & residual update

#version 460

#include "pressure.glsl"

layout(set = 2, binding = 0, r32f) uniform restrict image3D Pressure;
layout(set = 2, binding = 1, r32f) uniform restrict image3D Residual;
layout(set = 2, binding = 2) uniform texture3D Search;
layout(set = 2, binding = 3) uniform PcgScalars_ { PcgScalars Scalars; };

#define PRUPDATE_LAST_ITERATION 1

COMPUTE_PASS_VOLUME

void main() {
    ivec3 gridCoord = ivec3(gl_GlobalInvocationID);
    float marker = texelFetch(MarkerVolume, gridCoord, 0).x; // Empirically this test + skip is a speedup!
    if (marker != CELL_FLUID) {
        return;
    }

    float search = texelFetch(Search, gridCoord, 0).x;
    float alpha = Scalars.AlphaBeta;

    // Update pressure
    {
        float pressureBefore = imageLoad(Pressure, gridCoord).x;
        imageStore(Pressure, gridCoord, (pressureBefore + alpha * search).xxxx);
    }

    if (PushConstants.Mode == PRUPDATE_LAST_ITERATION)
        return;

    // Update residual
    // This is usually r = r - a * z, but we didn't store z!
    // So it's r = r - a * As
    //
    // Duplicating the work here is still faster since we saved on 2 reads and 1 write earlier
    // by merging initial dotproduct calculation (scalar multiply) into calculating As earlier.
    // (empirically confirmed)
    {
        float residualBefore = imageLoad(Residual, gridCoord).x;
        float searchTimesA = 0.0; // The auxillary z!
        {
            float markerX0 = texelFetch(MarkerVolume, gridCoord - ivec3(1, 0, 0), 0).x;
            float markerX1 = texelFetch(MarkerVolume, gridCoord + ivec3(1, 0, 0), 0).x;
            float markerY0 = texelFetch(MarkerVolume, gridCoord - ivec3(0, 1, 0), 0).x;
            float markerY1 = texelFetch(MarkerVolume, gridCoord + ivec3(0, 1, 0), 0).x;
            float markerZ0 = texelFetch(MarkerVolume, gridCoord - ivec3(0, 0, 1), 0).x;
            float markerZ1 = texelFetch(MarkerVolume, gridCoord + ivec3(0, 0, 1), 0).x;

            // This is the diagonal value of matrix A!
            float numNonSolidNeighbors = 0.0;
            numNonSolidNeighbors += float(markerX0 != CELL_SOLID);
            numNonSolidNeighbors += float(markerX1 != CELL_SOLID);
            numNonSolidNeighbors += float(markerY0 != CELL_SOLID);
            numNonSolidNeighbors += float(markerY1 != CELL_SOLID);
            numNonSolidNeighbors += float(markerZ0 != CELL_SOLID);
            numNonSolidNeighbors += float(markerZ1 != CELL_SOLID);

            // apply diagonal of A
            if (numNonSolidNeighbors > 0.0) {
                searchTimesA += numNonSolidNeighbors * texelFetch(Search, gridCoord, 0).x;
            }

            // apply other coefficients of A
            if (markerX0 == CELL_FLUID) {
                searchTimesA -= texelFetch(Search, gridCoord - ivec3(1, 0, 0), 0).x;
            }
            if (markerX1 == CELL_FLUID) {
                searchTimesA -= texelFetch(Search, gridCoord + ivec3(1, 0, 0), 0).x;
            }
            if (markerY0 == CELL_FLUID) {
                searchTimesA -= texelFetch(Search, gridCoord - ivec3(0, 1, 0), 0).x;
            }
            if (markerY1 == CELL_FLUID) {
                searchTimesA -= texelFetch(Search, gridCoord + ivec3(0, 1, 0), 0).x;
            }
            if (markerZ0 == CELL_FLUID) {
                searchTimesA -= texelFetch(Search, gridCoord - ivec3(0, 0, 1), 0).x;
            }
            if (markerZ1 == CELL_FLUID) {
                searchTimesA -= texelFetch(Search, gridCoord + ivec3(0, 0, 1), 0).x;
            }
        }
        imageStore(Residual, gridCoord, (residualBefore - alpha * searchTimesA).xxxx);
    }
}
