// Computes velocity divergence of VelocityVolumes and uses it to set the initial residual - which takes into account an intitial pressure guess.

#version 460

#include "pressure.glsl"

layout(set = 2, binding = 0, r32f) uniform restrict image3D Residual;
layout(set = 2, binding = 1, r32f) uniform restrict image3D InitialPressureGuess;

COMPUTE_PASS_VOLUME

#define DIVERGENCE_FIRST_STEP 0
#define DIVERGENCE_NOT_FIRST_STEP 1

float computeDivergenceForDirection(ivec3 coord, texture3D velocityVolume, uint oppositeWallType, const uint component) {
    ivec3 neighborCoord = coord;
    neighborCoord[component] -= 1;

    if (oppositeWallType == CELL_FLUID)
        return texelFetch(velocityVolume, coord, 0).x - texelFetch(velocityVolume, neighborCoord, 0).x;
    else if (oppositeWallType == CELL_SOLID)
        return texelFetch(velocityVolume, coord, 0).x;
    else
        return 0.0;
}

void main() {
    ivec3 gridCoord = ivec3(gl_GlobalInvocationID);

    // If there is no fluid, we don't need to compute divergence.
    // Divergence tells us how much fluid is going in/out. If we're at a air/solid cell then that's clearly zero as there's no fluid in the first
    // place!

    // However, in order to not pollute future initial pressure guesses, we zero set the InitialPressureGuess everywhere else.
    // (otherwise results from early steps influence much later ones which can lead to odd artifacts)
    uint marker = texelFetch(MarkerVolume, gridCoord, 0).x;
    if (marker != CELL_FLUID) {
        imageStore(InitialPressureGuess, gridCoord, vec4(0.0));
        return;
    }

    uint markerX0 = texelFetch(MarkerVolume, gridCoord - ivec3(1, 0, 0), 0).x;
    uint markerX1 = texelFetch(MarkerVolume, gridCoord + ivec3(1, 0, 0), 0).x;
    uint markerY0 = texelFetch(MarkerVolume, gridCoord - ivec3(0, 1, 0), 0).x;
    uint markerY1 = texelFetch(MarkerVolume, gridCoord + ivec3(0, 1, 0), 0).x;
    uint markerZ0 = texelFetch(MarkerVolume, gridCoord - ivec3(0, 0, 1), 0).x;
    uint markerZ1 = texelFetch(MarkerVolume, gridCoord + ivec3(0, 0, 1), 0).x;

    float divergence = computeDivergenceForDirection(gridCoord, VelocityVolumeX, markerX0, 0);
    divergence += computeDivergenceForDirection(gridCoord, VelocityVolumeY, markerY0, 1);
    divergence += computeDivergenceForDirection(gridCoord, VelocityVolumeZ, markerZ0, 2);

    // The residual is computed as r = b - A * x0
    // b is here divergence
    // x0 is our initial guess
    float residual = divergence;
    if (PushConstants.Mode == DIVERGENCE_FIRST_STEP) {
        imageStore(InitialPressureGuess, gridCoord, vec4(0.0));
    } else {
        float numNonSolidNeighbors = 0.0;
        numNonSolidNeighbors += float(markerX0 != CELL_SOLID);
        numNonSolidNeighbors += float(markerX1 != CELL_SOLID);
        numNonSolidNeighbors += float(markerY0 != CELL_SOLID);
        numNonSolidNeighbors += float(markerY1 != CELL_SOLID);
        numNonSolidNeighbors += float(markerZ0 != CELL_SOLID);
        numNonSolidNeighbors += float(markerZ1 != CELL_SOLID);
        if (numNonSolidNeighbors > 0.0)
            residual -= numNonSolidNeighbors * imageLoad(InitialPressureGuess, gridCoord).x;
        if (markerX0 == CELL_FLUID) {
            residual += imageLoad(InitialPressureGuess, gridCoord - ivec3(1, 0, 0)).x;
        }
        if (markerX1 == CELL_FLUID) {
            residual += imageLoad(InitialPressureGuess, gridCoord + ivec3(1, 0, 0)).x;
        }
        if (markerY0 == CELL_FLUID) {
            residual += imageLoad(InitialPressureGuess, gridCoord - ivec3(0, 1, 0)).x;
        }
        if (markerY1 == CELL_FLUID) {
            residual += imageLoad(InitialPressureGuess, gridCoord + ivec3(0, 1, 0)).x;
        }
        if (markerZ0 == CELL_FLUID) {
            residual += imageLoad(InitialPressureGuess, gridCoord - ivec3(0, 0, 1)).x;
        }
        if (markerZ1 == CELL_FLUID) {
            residual += imageLoad(InitialPressureGuess, gridCoord + ivec3(0, 0, 1)).x;
        }
    }

    imageStore(Residual, gridCoord, residual.xxxx);
}
