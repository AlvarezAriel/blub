// Computes velocity divergence of VelocityVolumes

#version 450

#include "hybrid_fluid.glsl"
#include "per_frame_resources.glsl"
#include "utilities.glsl"

layout(set = 2, binding = 0) uniform texture3D VelocityVolumeX;
layout(set = 2, binding = 1) uniform texture3D VelocityVolumeY;
layout(set = 2, binding = 2) uniform texture3D VelocityVolumeZ;
layout(set = 2, binding = 3) uniform utexture3D MarkerVolume;
// layout(set = 2, binding = 4) uniform texture3D DivergenceVolume;
// layout(set = 2, binding = 5) uniform texture3D PressureVolumeRead;
layout(set = 2, binding = 6, r32f) uniform restrict image3D DivergenceVolume;

COMPUTE_PASS_VOLUME

float computeDivergenceForDirection(ivec3 coord, texture3D velocityVolume, const uint component) {
    ivec3 neighborCoord = coord;
    neighborCoord[component] -= 1;

    uint oppositeWallType = texelFetch(MarkerVolume, neighborCoord, 0).x;
    if (oppositeWallType == CELL_FLUID)
        return texelFetch(velocityVolume, coord, 0).x - texelFetch(velocityVolume, neighborCoord, 0).x;
    else if (oppositeWallType == CELL_SOLID)
        return texelFetch(velocityVolume, coord, 0).x;
    else
        return 0.0;
}

void main() {
    ivec3 gridCoord = ivec3(gl_GlobalInvocationID);

    // Don't compute divergence if there's no fluid
    // Divergence tells us how much fluid is going in/out. If we're at a air/solid cell then that's clearly zero as there's no fluid in the first
    // place!
    if (texelFetch(MarkerVolume, gridCoord, 0).x != CELL_FLUID)
        return; // Clear? Nah, just means we need to be careful with debug viz!

    float divergence = computeDivergenceForDirection(gridCoord, VelocityVolumeX, 0);
    divergence += computeDivergenceForDirection(gridCoord, VelocityVolumeY, 1);
    divergence += computeDivergenceForDirection(gridCoord, VelocityVolumeZ, 2);

    imageStore(DivergenceVolume, gridCoord, divergence.xxxx);
}
