// An implementation of:
// A Narrow-Range Filter for Screen-Space Fluid Rendering, Truong et al. 2018
// http://www.cemyuksel.com/research/papers/narrowrangefilter.pdf

// With some flavoring of my own.

#version 460

#include "../fluid_render_info.glsl"
#include "../per_frame_resources.glsl"
#include "../utilities.glsl"

layout(set = 2, binding = 0, r32f) uniform restrict image2D DepthDest;
layout(set = 2, binding = 1) uniform texture2D DepthSource;

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// Maximum filter size (in one direction, i.e. 15 means that it covers a 31x31 square of pixels)
#define MAX_FILTER_SIZE 31

// Relationship between the standard deviation sigma (for gaussian kernel) and the filter size.
// (the lower, the boxier the filter gets)
#define SIGMA_TO_FILTERSIZE 6.0

// depthSampleA & depthSampleB are depth samples on opposing sides, both at the same distance to the middle.
void narrowRangeFilter(float depthSampleA, float depthSampleB, float centerDepth, float gaussianWeight, float mu, float delta, inout float delta_high,
                       inout float delta_low, inout float totalWeight, inout float filteredDepth) {
    if (isinf(depthSampleA) || depthSampleA == 0.0)
        return;
    if (isinf(depthSampleB) || depthSampleB == 0.0)
        return;
    if (depthSampleA > centerDepth + delta_high)
        return;
    if (depthSampleB > centerDepth + delta_high)
        return;

    if (depthSampleA < centerDepth - delta_low)
        depthSampleA = centerDepth - mu;
    else {
        delta_low = max(delta_low, centerDepth - depthSampleA + delta);
        delta_high = max(delta_high, depthSampleA - centerDepth + delta);
    }
    if (depthSampleB < centerDepth - delta_low)
        depthSampleB = centerDepth - mu;
    else {
        delta_low = max(delta_low, centerDepth - depthSampleB + delta);
        delta_high = max(delta_high, depthSampleB - centerDepth + delta);
    }

    totalWeight += gaussianWeight * 2.0;
    filteredDepth += (depthSampleA + depthSampleB) * gaussianWeight;
}

void main() {
    ivec2 screenCoord = ivec2(gl_GlobalInvocationID.xy);
    float centerDepth = texelFetch(DepthSource, screenCoord, 0).r;
    if (isinf(centerDepth) || centerDepth == 0.0) {
        return;
    }

    // TODO: Expose
    float worldSpaceSigma = Rendering.FluidParticleRadius * 1.7;
    float delta = 10.0 * Rendering.FluidParticleRadius;
    float mu = 1.0 * Rendering.FluidParticleRadius;

    float sigma = imageSize(DepthDest).y * worldSpaceSigma / (Camera.TanHalfVerticalFov * centerDepth * 2.0);
    float filterSizef = min(MAX_FILTER_SIZE, sigma * SIGMA_TO_FILTERSIZE);
    sigma = filterSizef * (1.0 / SIGMA_TO_FILTERSIZE); // correct sigma so we don't degenerate to a box filter
    float gaussianK = 0.5 / sq(sigma);
    int filterSize = int(ceil(filterSizef));

    float filteredDepth = centerDepth;
    float totalWeight = 0.0;

    float delta_high = delta;
    float delta_low = delta;

    // Sample from middle to outside
    for (int r = 1; r < filterSize; ++r) {
        // Go round the square, sampling 4 equidistant points at the time (starting with the corners)
        for (int i = 0; i < r * 2; ++i) {
            float gaussianWeight = exp(-(sq(r) + sq(r - i)) * gaussianK);

            float depthA = texelFetch(DepthSource, screenCoord + ivec2(r, r - i), 0).r;
            float depthB = texelFetch(DepthSource, screenCoord - ivec2(r, r - i), 0).r;
            narrowRangeFilter(depthA, depthB, centerDepth, gaussianWeight, mu, delta, delta_high, delta_low, totalWeight, filteredDepth);

            depthA = texelFetch(DepthSource, screenCoord + ivec2(r - i, -r), 0).r;
            depthB = texelFetch(DepthSource, screenCoord - ivec2(r - i, -r), 0).r;
            narrowRangeFilter(depthA, depthB, centerDepth, gaussianWeight, mu, delta, delta_high, delta_low, totalWeight, filteredDepth);
        }
    }
    filteredDepth /= totalWeight;
    // filteredDepth = centerDepth;
    imageStore(DepthDest, screenCoord, filteredDepth.rrrr);
}