// Extrapolates velocity into air and solid for easy access in particle update
// Note that we can run the extrapolation pass only once since we don't double buffer markers.

#version 450

#include "bindings_write_volume.glsl"

COMPUTE_PASS_VOLUME

// Total of 2 passes
// Don't need to update markers on last pass!
layout(push_constant) uniform PushConstants { uint PassIndex; };

void AccumulateNeighbors(float neighborCellType, ivec3 neighborCellCoord, inout vec3 accumulator, inout float accumulatedWeight) {
    if (neighborCellType == CELL_FLUID) {
        accumulator.x += imageLoad(VelocityVolumeX, neighborCellCoord).x;
        accumulator.y += imageLoad(VelocityVolumeY, neighborCellCoord).x;
        accumulator.z += imageLoad(VelocityVolumeZ, neighborCellCoord).x;
        accumulatedWeight += 1.0;
    }
}

void AccumulateNeighbors(ivec3 neighborCellCoord, inout vec3 accumulator, inout float accumulatedWeight) {
    float neighborCellType = texelFetch(MarkerVolume, neighborCellCoord, 0).x;
    AccumulateNeighbors(neighborCellType, neighborCellCoord, accumulator, accumulatedWeight);
}

void main() {
    vec3 velocityGridPosition = vec3(gl_GlobalInvocationID);
    ivec3 gridCoord = ivec3(gl_GlobalInvocationID);

    float cellType = texelFetch(MarkerVolume, gridCoord, 0).x;
    if (cellType == CELL_FLUID) {
        if (PassIndex == 0) {
            imageStore(MarkerVolumeWrite, gridCoord, vec4(CELL_FLUID));
        }
        return; // all good already!
    }

    // Direct neighbor cells are special, need them later.
    float cellTypePosX = texelFetch(MarkerVolume, gridCoord + ivec3(1, 0, 0), 0).x;
    float cellTypePosY = texelFetch(MarkerVolume, gridCoord + ivec3(0, 1, 0), 0).x;
    float cellTypePosZ = texelFetch(MarkerVolume, gridCoord + ivec3(0, 0, 1), 0).x;

    // Average velocity over neighbors.
    vec3 velocity = vec3(0.0);
    {
        float accumulatedWeight = 0.0;

        // direct neighbor cells.
        AccumulateNeighbors(cellTypePosX, gridCoord + ivec3(1, 0, 0), velocity, accumulatedWeight);
        AccumulateNeighbors(gridCoord - ivec3(1, 0, 0), velocity, accumulatedWeight);
        AccumulateNeighbors(cellTypePosY, gridCoord + ivec3(0, 1, 0), velocity, accumulatedWeight);
        AccumulateNeighbors(gridCoord - ivec3(0, 1, 0), velocity, accumulatedWeight);
        AccumulateNeighbors(cellTypePosZ, gridCoord + ivec3(0, 0, 1), velocity, accumulatedWeight);
        AccumulateNeighbors(gridCoord - ivec3(0, 0, 1), velocity, accumulatedWeight);

        if (PassIndex == 0) {
            float newCellType = cellType;
            if (accumulatedWeight > 0.0)
                newCellType = CELL_FLUID;
            imageStore(MarkerVolumeWrite, gridCoord, vec4(newCellType));
        }

        if (accumulatedWeight == 0.0)
            return;

        velocity /= accumulatedWeight;
    }
    // don't allow flow into solid cells
    // To avoid sticking to walls we allow velocity away from it even though it violates continuity equations.
    if (cellType == CELL_SOLID) {
        if (cellTypePosX != CELL_SOLID)
            velocity.x = max(0.0, velocity.x);
        if (cellTypePosY != CELL_SOLID)
            velocity.y = max(0.0, velocity.y);
        if (cellTypePosY != CELL_SOLID)
            velocity.z = max(0.0, velocity.z);
    }

    imageStore(VelocityVolumeX, gridCoord, velocity.xxxx);
    imageStore(VelocityVolumeY, gridCoord, velocity.yyyy);
    imageStore(VelocityVolumeZ, gridCoord, velocity.zzzz);
}