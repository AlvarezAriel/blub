// Computes velocity divergence of VelocityVolume

#version 450

#include "hybrid_fluid.glsl"
#include "per_frame_resources.glsl"
#include "utilities.glsl"

layout(set = 2, binding = 0) uniform texture3D VelocityVolume;
layout(set = 2, binding = 1) uniform utexture3D MarkerVolume;
// layout(set = 2, binding = 2) uniform texture3D DivergenceVolume;
// layout(set = 2, binding = 3) uniform texture3D PressureVolumeRead;
layout(set = 2, binding = 4, r32f) uniform restrict image3D DivergenceVolume;

COMPUTE_PASS_VOLUME

float computeDivergenceForDirection(ivec3 coord, vec3 currentCellStaggeredVelocities, const uint component) {
    coord[component] -= 1;

    uint oppositeWallType = texelFetch(MarkerVolume, coord, 0).x;
    if (oppositeWallType == CELL_FLUID)
        return currentCellStaggeredVelocities[component] - texelFetch(VelocityVolume, coord, 0)[component];
    else if (oppositeWallType == CELL_SOLID)
        return currentCellStaggeredVelocities[component];
    else
        return 0.0;
}

void main() {
    ivec3 gridCoord = ivec3(gl_GlobalInvocationID);

    // Don't compute divergence if there's no fluid
    // Divergence tells us how much fluid is going in/out. If we're at a air/solid cell then that's clearly zero as there's no fluid in the first
    // place!
    if (texelFetch(MarkerVolume, gridCoord, 0).x != CELL_FLUID)
        return; // Clear? Nah, just means we need to be careful with debug viz!

    vec3 currentCellStaggeredVelocities = texelFetch(VelocityVolume, gridCoord, 0).xyz;
    float divergence = computeDivergenceForDirection(gridCoord, currentCellStaggeredVelocities, 0);
    divergence += computeDivergenceForDirection(gridCoord, currentCellStaggeredVelocities, 1);
    divergence += computeDivergenceForDirection(gridCoord, currentCellStaggeredVelocities, 2);

    imageStore(DivergenceVolume, gridCoord, divergence.xxxx);
}
