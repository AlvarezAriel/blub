// Builds velocity grid from particles and llgrid
// Uses shepard interpolation on particles.

#version 450

#include "bindings_write_particles_volume.glsl"
#include "utilities.glsl"

COMPUTE_PASS_VOLUME

void gatherVelocitiesFromLinkedList(inout vec4 velocityAndWeight, vec3 velocityGridPosition, ivec3 llgridCoord) {
    uint particleIndex = imageLoad(LinkedListDualGrid, llgridCoord).r - 1;

    // while (particleIndex != INVALID_LINKED_LIST_PTR) {
    for (int i = 0; i < 32 && particleIndex != INVALID_LINKED_LIST_PTR; ++i) {
        vec3 d = saturate(vec3(1.0) - abs(velocityGridPosition - Particles[particleIndex].Position));
        float weight = d.x * d.y * d.z;
        velocityAndWeight += vec4(Particles[particleIndex].Velocity * weight, weight);
        particleIndex = Particles[particleIndex].LinkedListNext;
    }
}

void main() {
    vec3 velocityGridPosition = vec3(gl_GlobalInvocationID) + vec3(0.5); // velocity is stored at the center.
    ivec3 gridCoord = ivec3(gl_GlobalInvocationID);
    vec4 velocityAndWeight = vec4(0.0);
    gatherVelocitiesFromLinkedList(velocityAndWeight, velocityGridPosition, gridCoord - ivec3(0, 1, 0));
    gatherVelocitiesFromLinkedList(velocityAndWeight, velocityGridPosition, gridCoord - ivec3(0, 1, 1));
    gatherVelocitiesFromLinkedList(velocityAndWeight, velocityGridPosition, gridCoord - ivec3(0, 0, 0));
    gatherVelocitiesFromLinkedList(velocityAndWeight, velocityGridPosition, gridCoord - ivec3(0, 0, 1));
    gatherVelocitiesFromLinkedList(velocityAndWeight, velocityGridPosition, gridCoord - ivec3(1, 1, 0));
    gatherVelocitiesFromLinkedList(velocityAndWeight, velocityGridPosition, gridCoord - ivec3(1, 1, 1));
    gatherVelocitiesFromLinkedList(velocityAndWeight, velocityGridPosition, gridCoord - ivec3(1, 0, 0));
    gatherVelocitiesFromLinkedList(velocityAndWeight, velocityGridPosition, gridCoord - ivec3(1, 0, 1));

    if (velocityAndWeight.w > 0.0) {
        velocityAndWeight.xyz /= velocityAndWeight.w;

        // Apply global forces.
        // todo: make configurable
        velocityAndWeight.xyz += vec3(0.0, -9.81, 0.0) * Time.SimulationDelta;

        // Marked as fluid.
        velocityAndWeight.w = CELL_FLUID;
    } else {
        // Marked as air.
        velocityAndWeight = vec4(0.0, 0.0, 0.0, CELL_AIR);
    }

    imageStore(VelocityVolume, gridCoord, velocityAndWeight);
}