#version 450

#include "hybrid_fluid.glsl"
#include "particles.glsl"
#include "per_frame_resources.glsl"
#include "utilities.glsl"

layout(set = 2, binding = 0) buffer restrict ParticleBuffer { Particle Particles[]; };
// Origin texel represents position (0,0,0), NOT as one might expect (-0.5 / textureSize)
layout(set = 2, binding = 1) uniform texture3D VelocityVolume;

COMPUTE_PASS_PARTICLES

void main() {
    uint particleIndex = gl_GlobalInvocationID.x;
    if (particleIndex >= NumParticles)
        return;

    vec3 gridSize = vec3(textureSize(VelocityVolume, 0));

    // Fetch position from grid, trilinearly interpolated.
    vec3 originalPosition = Particles[particleIndex].Position;
    vec3 originalPositionGridTextureSpace = originalPosition / gridSize + 0.5 / gridSize;
    vec3 newVelocity = texture(sampler3D(VelocityVolume, SamplerTrilinearClamp), originalPositionGridTextureSpace).xyz;

    // Advect
    // TODO: Try something fancy like Runge Kutta. That would require sampling the grid more often though, so probably not worth it...
    // also didn't see any impls out there _actually_ doing RK (although many like talking of it...)
    vec3 newPosition = originalPosition + newVelocity * Time.SimulationDelta; // Euler Step.

    // Enforce boundary.
    newPosition = clamp(newPosition, vec3(0.5), gridSize - 0.5); // wrong since it can clamp movement in a single dimension. But good enough

    // Apply
    Particles[particleIndex].Velocity = newVelocity;
    Particles[particleIndex].Position = newPosition;
}