#version 460

#include "../fluid_render_info.glsl"
#include "../per_frame_resources.glsl"
#include "../utilities.glsl"

layout(set = 2, binding = 0) uniform texture2D FluidViewSpaceDepth;
layout(set = 2, binding = 1) uniform texture2D waterDepth;
layout(set = 2, binding = 2, HDR_BACKBUFFER_IMAGE_FORMAT) uniform restrict image2D BackbufferImage;

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

const float RefractionIndex_Water = 1.33;
const float RefractionIndex_Air = 1.00029;
const float RefractionAirToWater = RefractionIndex_Air / RefractionIndex_Water;
const float ReflectionCoefficient = (RefractionIndex_Air - RefractionIndex_Water) * (RefractionIndex_Air - RefractionIndex_Water) /
                                    ((RefractionIndex_Air + RefractionIndex_Water) * (RefractionIndex_Air + RefractionIndex_Water));

vec3 computeRefractionColor(float waterDepth) {
    // TODO: Compute refaction
    vec3 refractionRayResult = imageLoad(BackbufferImage, ivec2(gl_GlobalInvocationID.xy)).xyz;

    // TODO: can we adjust thickness value to become a "seen water depth value"? Refraction vector goes through more water than this.
    float waterRefractionDepth = waterDepth * 100;

    // Water color
    // This otherwise quite convincing reference assumes linear extinction, I'll go with exponential-
    // http://www.gamedev.net/page/reference/index.html/_/technical/graphics-programming-and-theory/rendering-water-as-a-post-process-effect-r2642
    // This leaves the questions: What are convining Extinction coefficients?
    // For that I solved the equations exp(-4.5 * R) = exp(-75 * G) = exp(-300 * B) = 0.001 (depths are from link above)
    // .. which is.. convincing pseudo physical! :)
    // In reality water color depends on a lot of factors: https://en.wikipedia.org/wiki/Color_of_water
    const vec3 ColorExtinctionCoefficient = vec3(1.53506, 0.0921034, 0.0230259);
    const vec3 SurfaceColor = vec3(0.003, 0.179, 0.270);
    const vec3 BigDepthColor = vec3(0.002, 0.001, 0.072);
    const float Opaqueness = 0.1;

    vec3 colorExtinction = saturate(exp(-waterRefractionDepth * ColorExtinctionCoefficient));
    vec3 normalLightingColor = vec3(1.0); // GlobalDirLightColor * nDotL + GlobalAmbient;
    vec3 waterColor = mix(refractionRayResult, SurfaceColor * normalLightingColor, saturate(waterRefractionDepth * Opaqueness));

    return mix(vec3(0.0), waterColor, colorExtinction);
}

// Computes world space position from standard depth buffer depth.
// (using "classic depth buffer", as defined in with our global camera matrices)
vec3 reconstructWorldPositionFromViewSpaceDepth(vec2 screenUv, float depth) {
    float x = screenUv.x * 2.0f - 1.0f;
    float y = (1.0 - screenUv.y) * 2.0f - 1.0f;
    vec3 viewSpace = vec3(Camera.NdcCameraSpaceProjected * vec2(x, y) * depth, depth);
    return viewSpace.x * Camera.Right + viewSpace.y * Camera.Up + viewSpace.z * Camera.Direction + Camera.Position;
}

void reconstructNormalAndPositionFromDepthbuffer(ivec2 screenCoord, vec2 screenPixelSize, out vec3 worldNormal, out vec3 worldPosition) {
    // Reconstruct normals as describe here:
    // https://wickedengine.net/2019/09/22/improved-normal-reconstruction-from-depth/
    // (Improved normal reconstruction from depth, Turanszkij, September 2019)
    // Btw. here is an even more thorough and expensive one: https://atyuwen.github.io/posts/normal-reconstruction/#fn:2

    ivec2 coordUp = screenCoord + ivec2(0, 1);
    ivec2 coordDown = screenCoord + ivec2(0, -1);
    ivec2 coordRight = screenCoord + ivec2(1, 0);
    ivec2 coordLeft = screenCoord + ivec2(-1, 0);

    // TODO: Shared memory for fetching depth.
    float depthCenter = texelFetch(FluidViewSpaceDepth, screenCoord, 0).r;
    worldPosition = reconstructWorldPositionFromViewSpaceDepth(screenCoord * screenPixelSize, depthCenter);
    float depthUp = texelFetch(FluidViewSpaceDepth, coordUp, 0).r;
    float depthRight = texelFetch(FluidViewSpaceDepth, coordRight, 0).r;
    float depthDown = texelFetch(FluidViewSpaceDepth, coordDown, 0).r;
    float depthLeft = texelFetch(FluidViewSpaceDepth, coordLeft, 0).r;

    uint bestDepthHorizontal = abs(depthRight - depthCenter) < abs(depthLeft - depthCenter) ? 1 : 2;
    uint bestDepthVertical = abs(depthDown - depthCenter) < abs(depthUp - depthCenter) ? 3 : 4;

    // TODO: Simplify
    vec3 p1;
    vec3 p2;
    if (bestDepthHorizontal == 1 && bestDepthVertical == 4) {
        p1 = reconstructWorldPositionFromViewSpaceDepth(coordRight * screenPixelSize, depthRight);
        p2 = reconstructWorldPositionFromViewSpaceDepth(coordUp * screenPixelSize, depthUp);
    } else if (bestDepthHorizontal == 1 && bestDepthVertical == 3) {
        p1 = reconstructWorldPositionFromViewSpaceDepth(coordDown * screenPixelSize, depthDown);
        p2 = reconstructWorldPositionFromViewSpaceDepth(coordRight * screenPixelSize, depthRight);
    } else if (bestDepthHorizontal == 2 && bestDepthVertical == 4) {
        p1 = reconstructWorldPositionFromViewSpaceDepth(coordUp * screenPixelSize, depthUp);
        p2 = reconstructWorldPositionFromViewSpaceDepth(coordLeft * screenPixelSize, depthLeft);
    } else { // if (bestDepthHorizontal == 2 && bestDepthVertical == 3)
        p1 = reconstructWorldPositionFromViewSpaceDepth(coordLeft * screenPixelSize, depthLeft);
        p2 = reconstructWorldPositionFromViewSpaceDepth(coordDown * screenPixelSize, depthDown);
    }

    // Classic version
    // p1 = reconstructWorldPositionFromViewSpaceDepth(coordRight * screenPixelSize, depthRight);
    // p2 = reconstructWorldPositionFromViewSpaceDepth(coordUp * screenPixelSize, depthUp);

    worldNormal = normalize(cross(p2 - worldPosition, p1 - worldPosition));
}

void main() {
    ivec2 screenCoord = ivec2(gl_GlobalInvocationID.xy);
    float waterDepth = texelFetch(waterDepth, screenCoord, 0).r;
    if (waterDepth == 0.0)
        return;

    vec3 GlobalDirLightDirection = normalize(vec3(-1.0, 0.5, 0.5));
    vec3 GlobalDirLightColor = vec3(1.0);

    vec2 screenPixelSize = vec2(1.0) / textureSize(FluidViewSpaceDepth, 0).xy;

    // Normal/Position (world coords)
    vec3 normal;
    vec3 position;
    reconstructNormalAndPositionFromDepthbuffer(screenCoord, screenPixelSize, normal, position);

    // vector to camera and camera distance
    vec3 toCamera = Camera.Position - position;
    float cameraDistance = length(toCamera);
    toCamera /= cameraDistance;

    // Normal dot Light - basic lighting term
    float nDotL = saturate(dot(normal, GlobalDirLightDirection));
    // Normal dot Camera - angle of viewer to water surface
    float nDotV = saturate(dot(normal, toCamera));
    // Schlick-Fresnel approx
    float fresnel = schlickFresnel(nDotV, ReflectionCoefficient);

    // specular lighting
    vec3 cameraDirReflection = normalize((2 * nDotV) * normal - toCamera);
    float specularAmount = pow(saturate(dot(cameraDirReflection, GlobalDirLightDirection)), 8.0);
    specularAmount *= fresnel;

    // Color components.
    vec4 previousColor = imageLoad(BackbufferImage, screenCoord);
    vec3 refractionColor = computeRefractionColor(waterDepth);
    vec3 reflectionColor = vec3(1.0); // todo, cubemap/screenspace reflection

    // Combine Refraction & Reflection & Specular
    vec3 color = mix(refractionColor, reflectionColor, fresnel) + GlobalDirLightColor * specularAmount;

    imageStore(BackbufferImage, screenCoord, vec4(color, 1.0));
}