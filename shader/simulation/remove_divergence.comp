// Subtracts pressure gradient from velocity volume to make it divergence free.
// (applies pressure forces)

#version 450

#include "../utilities.glsl"
#include "bindings_write_particles_volume.glsl"

COMPUTE_PASS_VOLUME

void main() {
    vec3 velocityGridPosition = vec3(gl_GlobalInvocationID);
    ivec3 gridCoord = ivec3(gl_GlobalInvocationID);

    vec4 velocity = imageLoad(VelocityVolume, gridCoord);

    uint cellType = imageLoad(MarkerVolume, gridCoord).x;
    uvec3 cellTypeNeighbors = uvec3(imageLoad(MarkerVolume, gridCoord + ivec3(1, 0, 0)).x, imageLoad(MarkerVolume, gridCoord + ivec3(0, 1, 0)).x,
                                    imageLoad(MarkerVolume, gridCoord + ivec3(0, 0, 1)).x);

    // Compute pressure gradient with central differences
    float pressureAtCenter = cellType == CELL_FLUID ? texelFetch(PressureVolume, gridCoord, 0).x : 0.0;
    float pressurePosX = cellTypeNeighbors.x == CELL_FLUID ? texelFetch(PressureVolume, gridCoord + ivec3(1, 0, 0), 0).x : 0.0;
    float pressurePosY = cellTypeNeighbors.y == CELL_FLUID ? texelFetch(PressureVolume, gridCoord + ivec3(0, 1, 0), 0).x : 0.0;
    float pressurePosZ = cellTypeNeighbors.z == CELL_FLUID ? texelFetch(PressureVolume, gridCoord + ivec3(0, 0, 1), 0).x : 0.0;

    velocity.x -= pressurePosX - pressureAtCenter;
    velocity.y -= pressurePosY - pressureAtCenter;
    velocity.z -= pressurePosZ - pressureAtCenter;

    // Reenforce boundary condition (any pressure sampled in solids was garbage)
    velocity.xyz = enforceBoundaryCondition(velocity.xyz, cellType == CELL_SOLID, equal(cellTypeNeighbors, uvec3(CELL_SOLID)));

    // Write result.
    // TODO: skip write if not needed?
    imageStore(VelocityVolume, gridCoord, velocity);
}