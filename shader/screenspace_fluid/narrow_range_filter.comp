// An implementation of:
// A Narrow-Range Filter for Screen-Space Fluid Rendering, Truong et al. 2018
// http://www.cemyuksel.com/research/papers/narrowrangefilter.pdf

// With some flavoring of my own.

#version 460

#include "../fluid_render_info.glsl"
#include "../per_frame_resources.glsl"
#include "../utilities.glsl"

layout(set = 2, binding = 0, r32f) uniform restrict image2D DepthDest;
layout(set = 2, binding = 1) uniform texture2D DepthSource;

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

// Maximum filter size (in one direction, i.e. 15 means that it covers a 31x31 square of pixels)
#define MAX_FILTER_SIZE 31

// Relationship between the standard deviation sigma (for gaussian kernel) and the filter size.
// (the lower, the boxier the filter gets)
#define SIGMA_TO_FILTERSIZE 6.0

void narrowRangeFilter(float depth, float centerDepth, float gaussianWeight, inout float totalWeight, inout float filteredDepth) {
    if (isinf(depth) || depth == 0.0)
        return;

    // TODO: Expose
    float mu = Rendering.FluidParticleRadius;
    float delta = 10.0 * Rendering.FluidParticleRadius;

    if (depth > centerDepth + delta)
        return;
    if (depth < centerDepth - delta)
        depth = centerDepth - mu;

    totalWeight += gaussianWeight;
    filteredDepth += depth * gaussianWeight;
}

void main() {
    ivec2 screenCoord = ivec2(gl_GlobalInvocationID.xy);
    float centerDepth = texelFetch(DepthSource, screenCoord, 0).r;
    if (isinf(centerDepth) || centerDepth == 0.0) {
        return;
    }

    // TODO: Expose
    float worldSpaceSigma = Rendering.FluidParticleRadius * 1.8;
    float mu = Rendering.FluidParticleRadius;
    float delta = 10.0 * Rendering.FluidParticleRadius;

    float sigma = imageSize(DepthDest).y * worldSpaceSigma / (Camera.TanHalfVerticalFov * centerDepth * 2.0);
    float filterSizef = min(MAX_FILTER_SIZE, sigma * SIGMA_TO_FILTERSIZE);
    sigma = filterSizef * (1.0 / SIGMA_TO_FILTERSIZE); // correct sigma so we don't degenerate to a box filter
    float gaussianK = 0.5 / sq(sigma);
    int filterSize = int(ceil(filterSizef));

    float filteredDepth = centerDepth;
    float totalWeight = 0.0;

    // Sample from middle to outside
    for (int r = 1; r < filterSize; ++r) {
        // Go round the square, sampling 4 equidistant points at the time (starting with the corners)
        for (int i = 0; i < r * 2; ++i) {
            float gaussianWeight = exp(-(sq(r) + sq(r - i)) * gaussianK);

            narrowRangeFilter(texelFetch(DepthSource, screenCoord + ivec2(r, r - i), 0).r, centerDepth, gaussianWeight, totalWeight, filteredDepth);
            narrowRangeFilter(texelFetch(DepthSource, screenCoord + ivec2(r - i, -r), 0).r, centerDepth, gaussianWeight, totalWeight, filteredDepth);
            narrowRangeFilter(texelFetch(DepthSource, screenCoord - ivec2(r, r - i), 0).r, centerDepth, gaussianWeight, totalWeight, filteredDepth);
            narrowRangeFilter(texelFetch(DepthSource, screenCoord - ivec2(r - i, -r), 0).r, centerDepth, gaussianWeight, totalWeight, filteredDepth);
        }
    }
    filteredDepth /= totalWeight;
    // filteredDepth = centerDepth;
    imageStore(DepthDest, screenCoord, filteredDepth.rrrr);
}